<!doctype html>
<html><head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="manifest" href="manifest.webmanifest?v=v4.6.4b-20250817022613"/>
<title>Brainlock</title>
<style>
:root {--bg:#0b0b0f;--panel:#121218;--muted:#8a8a96;--text:#f5f7fa;--accent:#fff;--ok:#73e2a7;--miss:#ff7575;--line:rgba(255,255,255,.08);--pill:9999px;--radius:18px;}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{background:var(--bg);color:var(--text);margin:0;font-family:-apple-system,Inter,system-ui,sans-serif;min-height:100dvh}
.app{display:grid;grid-template-rows:auto auto 1fr auto;min-height:100dvh}
.topbar{display:flex;justify-content:space-between;align-items:center;padding:16px}
.iconbtn{width:44px;height:44px;border-radius:var(--pill);border:1px solid var(--line);background:#1a1a22;color:var(--text)}
.skate-top{padding:6px 12px 0;display:flex;justify-content:center;gap:12px}
.skate-top span{font-weight:900;font-size:clamp(64px,12vw,96px);opacity:.28;letter-spacing:2px}
.skate-top span.on{opacity:1;color:var(--miss)}
.content{padding:0 16px 24px}
.card{background:#121218;border:1px solid var(--line);border-radius:18px;padding:14px}
.huge{font-size:32px;font-weight:900}
.muted{color:var(--muted);font-size:13px}
.badge{padding:6px 10px;border:1px solid var(--line);border-radius:999px;color:var(--muted);font-size:12px}
.btnrow{display:flex;gap:10px;flex-wrap:wrap}
.cta{flex:1 1 0;padding:14px 16px;border-radius:999px;border:none;font-weight:900}
.cta.primary{background:var(--accent);color:#000}
.cta.ok{background:var(--ok);color:#000}
.cta.miss{background:var(--miss);color:#000}
.cta.ghost{background:transparent;border:1px solid rgba(255,255,255,.14);color:var(--text)}
.attempts{display:flex;gap:8px}
.dot{width:18px;height:18px;border:2px solid rgba(255,255,255,.25);border-radius:50%;display:grid;place-items:center}
.dot.active{border-color:#4da3ff}
.dot .m{font-size:12px}
.hidden{display:none!important}
.tray{position:sticky;bottom:0;padding:16px;background:linear-gradient(180deg,transparent,rgba(11,11,15,.9) 40%,rgba(11,11,15,1))}
.tray-inner{background:#121218;border:1px solid var(--line);border-radius:24px;padding:14px}
.sheet{border:none;width:100%;max-width:720px;border-radius:24px 24px 0 0;position:fixed;bottom:0;left:50%;transform:translateX(-50%);background:#121218;color:var(--text)}
.sheet::backdrop{background:rgba(0,0,0,.55)}
.row{display:flex;gap:10px;align-items:center}
.row-sb{display:flex;justify-content:space-between;gap:10px;align-items:center}
.subs{display:flex;flex-wrap:wrap;gap:8px;margin:8px 0 14px}
.toggle{padding:10px 14px;border:1px solid rgba(255,255,255,.14);border-radius:999px}
.toggle.on{background:#1f1f27;border-color:rgba(255,255,255,.28)}
.scorepeek{font-size:12px;color:var(--muted);text-decoration:underline dotted;cursor:pointer}
</style>
</head>
<body>
<div class="app">
  <div class="topbar">
    <div>Brainlock</div>
    <div class="row">
      <button id="dbgBtn" class="iconbtn">DBG</button>
    </div>
  </div>

  <div class="skate-top" id="skTop"><span>S</span><span>K</span><span>A</span><span>T</span><span>E</span></div>

  <div class="content">
    <div class="card">
      <div class="row-sb">
        <div>
          <div id="trickText" class="huge">Tap Start Session</div>
          <div class="row">
            <div id="subText" class="muted">You have 3 tries per trick.</div>
            <div id="attempts" class="attempts"></div>
          </div>
          <div id="scorePeek" class="scorepeek"></div>
        </div>
        <div>
          <div class="badge" id="levelBadge">Level 1</div>
          <div class="badge" id="modeBadge">Mode: SKATE</div>
        </div>
      </div>
    </div>

    <div style="height:12px"></div>

    <div class="card">
      <div class="row" style="justify-content:space-between">
        <div><div class="muted" style="font-size:11px">Score</div><div id="scoreVal">0</div></div>
        <div><div class="muted" style="font-size:11px">High</div><div id="highVal">0</div></div>
        <div><div class="muted" style="font-size:11px">Streak</div><div id="streakVal">0</div></div>
      </div>
    </div>

    <div style="height:12px"></div>

    <div class="card">
      <div class="btnrow">
        <button id="optionsBtn" class="cta ghost">Game Options</button>
        <button id="endBtnModule" class="cta ghost hidden">End Session</button>
      </div>
    </div>
  </div>

  <div class="tray">
    <div class="tray-inner">
      <div id="trayStart"><button id="startBtn" class="cta primary">Start a New Session</button></div>
      <div id="trayActive" class="hidden btnrow">
        <button id="landBtn" class="cta ok">Land</button>
        <button id="missBtn" class="cta miss">Miss</button>
        <button id="skipBtn" class="cta ghost">Skip</button>
      </div>
      <div id="trayLanded" class="hidden"><button id="nextBtnLanded" class="cta primary">Next Trick</button></div>
      <div id="trayMissed" class="hidden"><button id="nextBtnMissed" class="cta primary">Next Trick</button></div>
      <div id="trayOver" class="hidden"><button id="restartBtn" class="cta primary">Start a New Session</button></div>
    </div>
  </div>
</div>

<dialog id="opt" class="sheet">
  <div style="display:flex;justify-content:space-between;align-items:center;padding:14px;border-bottom:1px solid rgba(255,255,255,.08)">
    <div>Game Options</div>
    <button id="closeOpt" class="iconbtn">✕</button>
  </div>
  <div style="padding:14px">
    <div class="row">
      <span class="muted">Level 1–10</span>
      <input id="level" type="range" min="1" max="10" value="7" style="flex:1"/>
      <span id="levelVal" style="font-family:ui-monospace">7</span>
    </div>
    <div class="subs" id="stanceChips"></div>
    <div class="subs" id="obChip"></div>
    <div class="subs" id="flipChips"></div>
    <div class="subs" id="grindChips"></div>
  </div>
</dialog>

<script>
const bindTap=(el,fn)=>{ if(!el) return; let armed=true;
  el.addEventListener('pointerdown',()=>armed=true,{passive:true});
  el.addEventListener('pointerup',e=>{ if(!armed) return; armed=false; fn(e); },{passive:true});
  el.addEventListener('keyup',e=>{ if(e.key==='Enter'||e.key===' ') fn(e); });
};

const OBST={ "ledge":2, "flatbar":2, "rail":2, "hubba":3, "handrail":3, "box":1, "curb":1, "flat":1, "bank":1, "manual pad":1, "gap":2 };
const FLIPS=["kickflip","heelflip","varial kickflip","varial heelflip","hardflip","inward heelflip","tre flip","laser flip"];
const FLIP_MIN={ "kickflip":1, "heelflip":1, "varial kickflip":3, "varial heelflip":3, "hardflip":4, "inward heelflip":4, "tre flip":6, "laser flip":8 };
const FLIP_OBS={ "kickflip":["flat","bank","gap","manual pad","quarterpipe"], "heelflip":["flat","bank","gap","manual pad","quarterpipe"], "varial kickflip":["flat","bank","gap","quarterpipe"], "varial heelflip":["flat","bank","gap","quarterpipe"], "hardflip":["flat","bank","gap"], "inward heelflip":["flat","bank","gap"], "tre flip":["flat","bank","gap"], "laser flip":["flat","bank","gap"] };
const GRINDS=["50-50","5-0","boardslide","noseslide","tailslide","lipslide","smith","feeble","crooked","nosegrind","overcrook","bluntslide","noseblunt"];
const GRIND_MIN={ "50-50":2, "5-0":3, "boardslide":3, "noseslide":3, "tailslide":4, "lipslide":4, "smith":5, "feeble":5, "crooked":5, "nosegrind":5, "overcrook":6, "bluntslide":7, "noseblunt":8 };
const GRIND_OBS={ "50-50":["curb","box","ledge","flatbar","rail","hubba","handrail"], "5-0":["curb","box","ledge","flatbar","rail","hubba","handrail"], "boardslide":["flatbar","rail","handrail"], "noseslide":["curb","box","ledge"], "tailslide":["curb","ledge","hubba"], "lipslide":["flatbar","rail","handrail"], "smith":["ledge","flatbar","rail","hubba","handrail"], "feeble":["flatbar","rail","handrail"], "crooked":["ledge","hubba"], "nosegrind":["ledge","hubba"], "overcrook":["ledge","hubba","handrail"], "bluntslide":["ledge","hubba","handrail"], "noseblunt":["ledge","hubba","handrail"] };

const SCORE={ stance:{ fakie:.2, nollie:.25, switch:.25 }, flip:{ "kickflip":.3, "heelflip":.35, "varial kickflip":.45, "varial heelflip":.5, "hardflip":.55, "inward heelflip":.6, "tre flip":.8, "laser flip":.85 }, spin:{ "180":.1, "360":.3 }, grind:{ "50-50":.3, "5-0":.35, "boardslide":.35, "noseslide":.4, "tailslide":.45, "lipslide":.5, "smith":.6, "feeble":.65, "crooked":.7, "nosegrind":.7, "overcrook":.85, "bluntslide":.8, "noseblunt":.9 }, obs:{ flat:0, "manual pad":.1, box:.1, curb:.15, ledge:.25, hubba:.35, flatbar:.35, rail:.45, handrail:.55, gap:.5, bank:.25 } };

function rand(a){return a[Math.floor(Math.random()*a.length)];}
function weightedPick(a,fn){const arr=a.map(v=>({v,w:Math.max(0,fn(v))})); const tot=arr.reduce((s,o)=>s+o.w,0)||1; let r=Math.random()*tot; for(const x of arr){ if((r-=x.w)<=0) return x.v;} return arr[arr.length-1].v; }
function levelMaxTier(l){return [1,1,1,1,2,2,3,3,3,3][l-1]||3;}
function pickObstacle(l,enabled){const pool=[...enabled].filter(o=>OBST[o]<=levelMaxTier(l)); const wByL={flat:[10,9,9,8,7,6,5,4,3,2],ledge:[0,0,2,3,4,5,6,7,8,8],rail:[0,0,0,2,3,4,5,6,7,7],flatbar:[0,0,1,2,3,4,5,6,7,7],hubba:[0,0,0,1,2,4,6,7,8,9],handrail:[0,0,0,0,0,2,4,6,7,8],gap:[0,0,1,2,3,4,5,6,6,7],box:[8,8,7,7,6,5,4,3,2,2],curb:[8,8,7,7,6,5,5,4,3,2],bank:[7,7,7,6,5,4,3,3,2,2],"manual pad":[10,10,9,8,7,6,5,4,3,2]}; const L=l-1; return weightedPick(pool,o=>(wByL[o]||[1])[L]||1)||'flat';}
function allowedFlipOnObs(f,o,l){return l>=FLIP_MIN[f] && (FLIP_OBS[f]||[]).includes(o);}
function allowedGrindOnObs(g,o,l){return l>=GRIND_MIN[g] && (GRIND_OBS[g]||[]).includes(o);}
function pickFlip(l,o,subs){const L=l-1; const weights={"kickflip":[10,10,9,9,8,7,6,5,4,3],"heelflip":[10,10,9,9,8,7,6,5,4,3],"varial kickflip":[0,0,6,7,8,8,7,6,5,4],"varial heelflip":[0,0,6,7,8,8,7,6,5,4],hardflip:[0,0,0,6,7,8,8,7,6,6],"inward heelflip":[0,0,0,6,7,8,8,7,6,6],"tre flip":[0,0,0,0,0,6,8,9,10,10],"laser flip":[0,0,0,0,0,0,0,6,8,10]};
  const pool=[...subs].filter(n=>allowedFlipOnObs(n,o,l)); return pool.length?weightedPick(pool,n=>(weights[n]||[])[L]||1):null;}
function pickGrind(l,o,subs){const L=l-1; const weights={"50-50":[0,7,8,9,9,9,9,8,7,6],"5-0":[0,0,7,8,9,9,9,8,7,6],boardslide:[0,0,6,8,9,9,9,8,7,6],noseslide:[0,0,6,8,9,9,8,7,6,5],tailslide:[0,0,0,6,8,9,9,8,7,6],lipslide:[0,0,0,6,8,9,9,8,7,6],smith:[0,0,0,0,6,8,9,9,8,7],feeble:[0,0,0,0,6,8,9,9,8,7],crooked:[0,0,0,0,6,8,9,9,8,7],nosegrind:[0,0,0,0,6,8,9,9,8,7],overcrook:[0,0,0,0,0,6,8,9,9,9],bluntslide:[0,0,0,0,0,0,6,8,9,9],noseblunt:[0,0,0,0,0,0,0,6,8,9]};
  const pool=[...subs].filter(n=>allowedGrindOnObs(n,o,l)); return pool.length?weightedPick(pool,n=>(weights[n]||[])[L]||1):null;}

function comboPatterns(l,ob){const grindable=new Set(["ledge","flatbar","rail","hubba","handrail","box","curb"]);
  const base=["flip-only","grind-only"];
  const extra=[];
  if(l>=5) extra.push("flip→grind","grind→flip out");
  if(l>=7) extra.push("spin+flip→grind","flip→grind+spin out","grind→flip+spin out","spin→grind+flip out");
  if(l>=9) extra.push("spin+flip→grind→spin+flip out");
  const all=base.concat(extra);
  return all.filter(p=> p.includes("grind")?grindable.has(ob):true );
}

function textFor(t){
  const parts=[];
  if(t.stance && t.stance!=="regular") parts.push(t.stance);
  if(t.spinIn) parts.push(t.spinIn+"°");
  if(t.flipIn) parts.push(t.flipIn);
  if(t.grind) parts.push((t.direction||"FS")+" "+t.grind);
  if(t.flipOut || t.spinOut){
    let out="";
    if(t.flipOut) out+=t.flipOut+" ";
    if(t.spinOut) out+=t.spinOut+"° ";
    parts.push("+ "+out.trim()+" out");
  }
  parts.push("on "+t.obstacle);
  return parts.join(" ").replace(/\s+/g," ").trim();
}

const $=id=>document.getElementById(id);
const ui={trickText:$("trickText"),subText:$("subText"),attempts:$("attempts"),scorePeek:$("scorePeek"),
levelBadge:$("levelBadge"),modeBadge:$("modeBadge"),
trayStart:$("trayStart"),trayActive:$("trayActive"),trayLanded:$("trayLanded"),trayMissed:$("trayMissed"),trayOver:$("trayOver"),
startBtn:$("startBtn"),landBtn:$("landBtn"),missBtn:$("missBtn"),skipBtn:$("skipBtn"),nextBtnLanded:$("nextBtnLanded"),nextBtnMissed:$("nextBtnMissed"),restartBtn:$("restartBtn"),
optionsBtn:$("optionsBtn"),opt:$("opt"),closeOpt:$("closeOpt"),
level:$("level"),levelVal:$("levelVal"),stanceChips:$("stanceChips"),obChip:$("obChip"),flipChips:$("flipChips"),grindChips:$("grindChips"),
scoreVal:$("scoreVal"),streakVal:$("streakVal"),highVal:$("highVal"),skTop:$("skTop")};

const App={
  level:7, stances:new Set(["regular","fakie","nollie","switch"]), obstacles:new Set(Object.keys(OBST)),
  flips:new Set(FLIPS), grinds:new Set(GRINDS),
  flow:0, score:0, letters:0, attempt:1, tray:"start", repeatMap:new Map(), current:null, misses:[], lands:[]
};

function setTray(s){["trayStart","trayActive","trayLanded","trayMissed","trayOver"].forEach(id=>ui[id].classList.add("hidden")); ui["tray"+s.charAt(0).toUpperCase()+s.slice(1)].classList.remove("hidden"); App.tray=s; renderAttempts();}
function renderAttempts(){ui.attempts.innerHTML=""; for(let i=1;i<=3;i++){const d=document.createElement("div"); d.className="dot"; if(i===App.attempt && App.tray==="active") d.classList.add("active"); if(App.misses.includes(i)){const m=document.createElement("div");m.className="m";m.textContent="×";d.appendChild(m);} if(App.tray==="landed"&&App.lands.includes(i)){const m=document.createElement("div");m.className="m";m.textContent="✓";d.appendChild(m);} ui.attempts.appendChild(d);}}
function letters(n){Array.from(ui.skTop.children).forEach((el,i)=>el.classList.toggle("on",i<n));}
function updateHUD(){ui.levelBadge.textContent="Level "+App.level; ui.streakVal.textContent=App.flow; ui.scoreVal.textContent=App.score; letters(App.letters); const p=predict(); ui.scorePeek.textContent=p?("This attempt: +"+p.total):"";}

function pick(){const ob=pickObstacle(App.level,App.obstacles); const patterns=comboPatterns(App.level,ob); const pat=weightedPick(patterns,p=> (App.level<=6? (p.includes("→")?5:(p==="flip-only"?8:6)) : (p.includes("→")?8:5)) ); const dir=Math.random()<.5?"FS":"BS";
  const t={obstacle:ob, stance:weightedPick([...App.stances],s=>({regular:10,fakie:3,nollie:3,switch:3}[s]||1))};
  const f=pickFlip(App.level,ob,App.flips); const f2=pickFlip(App.level,ob,App.flips); const g=pickGrind(App.level,ob,App.grinds);
  if(pat==="flip-only"){t.flipIn=f;}
  else if(pat==="grind-only"){t.grind=g;t.direction=dir;}
  else if(pat==="flip→grind"){t.flipIn=f;t.grind=g;t.direction=dir;}
  else if(pat==="grind→flip out"){t.grind=g;t.direction=dir;t.flipOut=f||f2;}
  else if(pat==="spin+flip→grind"){t.spinIn=(Math.random()<.7?180:360);t.flipIn=f;t.grind=g;t.direction=dir;}
  else if(pat==="flip→grind+spin out"){t.flipIn=f;t.grind=g;t.direction=dir;t.spinOut=(Math.random()<.7?180:360);}
  else if(pat==="grind→flip+spin out"){t.grind=g;t.direction=dir;t.flipOut=f||f2;t.spinOut=(Math.random()<.7?180:360);}
  else if(pat==="spin→grind+flip out"){t.spinIn=(Math.random()<.7?180:360);t.grind=g;t.direction=dir;t.flipOut=f||f2;}
  else if(pat==="spin+flip→grind→spin+flip out"){t.spinIn=(Math.random()<.7?180:360);t.flipIn=f;t.grind=g;t.direction=dir;t.spinOut=360;t.flipOut=f2||f;}
  if(pat.includes("grind") && !t.grind) return pick();
  if(pat.includes("flip") && !t.flipIn && !t.flipOut) return pick();
  t.pattern=pat; return t;
}

function predict(){ if(!App.current) return null; const t=App.current;
  let base=1.0;
  if(t.flipIn) base+=(SCORE.flip[t.flipIn]||0);
  if(t.flipOut) base+=((SCORE.flip[t.flipOut]||0)*0.9);
  if(t.spinIn) base+=(SCORE.spin[String(t.spinIn)]||0);
  if(t.spinOut) base+=((SCORE.spin[String(t.spinOut)]||0)*0.9);
  if(t.grind) base+=(SCORE.grind[t.grind]||0);
  base+=(SCORE.obs[t.obstacle]||0);
  const attemptM=({1:1,2:.85,3:.75}[App.attempt]||1);
  const flowM=1+Math.min(App.flow*0.03,0.15);
  const total=Math.round(100*base*attemptM*flowM);
  return {base,attemptM,flowM,total};
}

function nextTrick(){App.current=pick(); App.attempt=1; App.misses=[]; App.lands=[]; ui.trickText.textContent=textFor(App.current); ui.subText.textContent="Attempt 1 of 3"; renderAttempts(); updateHUD();}

function land(){const s=predict(); App.score+=s.total; App.flow+=1; App.lands.push(App.attempt); setTray("landed"); ui.subText.textContent="+"+s.total+" (tap score for breakdown)"; updateHUD();}
function miss(){App.misses.push(App.attempt); if(App.attempt>=3){App.flow=0; App.letters=Math.min(5,(App.letters||0)+1); setTray("missed");} else {App.attempt+=1; setTray("active"); ui.subText.textContent="Miss (attempt "+App.attempt+" of 3)";} updateHUD();}
function skip(){App.flow=0; nextTrick(); setTray("active");}
function end(){ui.trickText.textContent="Session Over"; setTray("over");}

bindTap(ui.startBtn,()=>{nextTrick(); setTray("active");});
bindTap(ui.restartBtn,()=>{nextTrick(); setTray("active");});
bindTap(ui.landBtn,land); bindTap(ui.missBtn,miss); bindTap(ui.skipBtn,skip);
bindTap(ui.nextBtnLanded,nextTrick); bindTap(ui.nextBtnMissed,nextTrick);
bindTap(ui.optionsBtn,()=>ui.opt.showModal()); bindTap(ui.closeOpt,()=>ui.opt.close());

function chip(container, label, set){const el=document.createElement("div"); el.className="toggle"+(set.has(label)?" on":""); el.textContent=label; bindTap(el,()=>{ if(set.has(label)) set.delete(label); else set.add(label); el.classList.toggle("on");}); container.appendChild(el);}
function renderChips(){ui.stanceChips.innerHTML=""; ["regular","fakie","nollie","switch"].forEach(s=>chip(ui.stanceChips,s,App.stances));
  ui.obChip.innerHTML=""; Object.keys(OBST).forEach(o=>chip(ui.obChip,o,App.obstacles));
  ui.flipChips.innerHTML=""; FLIPS.forEach(f=>chip(ui.flipChips,f,App.flips));
  ui.grindChips.innerHTML=""; GRINDS.forEach(g=>chip(ui.grindChips,g,App.grinds));
}
renderChips();
ui.level.addEventListener("input",e=>{App.level=+e.target.value; ui.levelVal.textContent=App.level;});

bindTap(ui.scorePeek,()=>{const s=predict(); if(!s) return; alert(["If you land now:","Base: "+s.base.toFixed(2),"Attempt ×"+s.attemptM.toFixed(2),"Flow ×"+s.flowM.toFixed(2),"Total: "+s.total].join("\n"));});
</script>
</body></html>
